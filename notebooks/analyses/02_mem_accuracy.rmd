---
title: "02_mem_accuracy.rmd"
author: "Arlene L."
date: "2025-10-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
# Suppressing message from here pkg

# Load in packages
library(here) 
library(tidyverse)
library(mousetrap) # for processing mouse trajectories
library(ggplot2)
library(ggbeeswarm)
library(cowplot) # for grouped plots
library(lmerTest) # for lm/lmer p values
library(sjPlot)
```

Description: In this script, we will 1) plot the memory accuracy (i.e., item frequency) across conditions and 2) relate memory accuracy to mousetracking measures (i.e., MAD) from the decision phase.

#### Set up directories
```{r}
rootPath <- here::here()
dataPath <- file.path(rootPath, 'data/processed/trajectories')
mem_dataPath <- file.path(rootPath, 'data/processed/acc')

# Get subject files (for mousetracking trajectoties)
sub_files <- list.files(dataPath, full.names = T, recursive = T)

# Also, get subject files (for memory accuracy) 
sub_mem_files <- list.files(mem_dataPath, full.names = T, recursive = T)

# Establish plot colors 
uni_color <- c('#FFD93D'); comp_color <- c('#762E84')
```


#### Obtain mouse data for selected participants
```{r}
# Prepare dataframe for everyone's data... 
mouse_enc_all <- data.frame()

for (s in sub_files){
  curr_mouse <- read.csv(s)
  mouse_enc_all<- rbind(mouse_enc_all, curr_mouse)}

# Reset the indices for the mouse_enc_all dataframe 
rownames(mouse_enc_all) <- NULL
```

```{r}
# For each subject... 
for (s in unique(mouse_enc_all$sub_label)){
  
  # Deal with current subject 
  sub_mouse_enc <- subset(mouse_enc_all, sub_label == s)
  
  # For each unique object, start naming objects 
  for (obj in unique(sub_mouse_enc$stimulus_name)){
    
    # Deal with the current object...
    curr_obj <- subset(sub_mouse_enc, stimulus_name == obj)
    
    # Sort by trial (+ assign pairmate labels)
    curr_obj <- curr_obj[order(curr_obj$Trial.Number),]
    mouse_enc_all[rownames(curr_obj)[1], 'pairmate_num'] <- 'first'
    
    if (nrow(curr_obj) == 2){mouse_enc_all[rownames(curr_obj)[2], 'pairmate_num'] <- 'second'}}}

# Then, create a column that combines the pairmate number and condition...
mouse_enc_all$cond_pairmate <- paste(mouse_enc_all$condition, mouse_enc_all$pairmate_num, sep='-')
```

```{r}
# Only take the paired information for now
enc_mouse_paired <- subset(mouse_enc_all, paired_status=='paired')

# Also, take the trials in which both pairmates were correct
enc_mouse_paired <- enc_mouse_paired %>% subset(both_enc_acc == 1)

# Factor our pairmate column into the order we want it to be
enc_mouse_paired$cond_pairmate <- factor(enc_mouse_paired$cond_pairmate, c('unique-first', 'unique-second', 'competing-first', 'competing-second'))

#### Exclude trials that do not have any mouse coordinates
enc_mouse_paired <- subset(enc_mouse_paired, x_pos != '')
```

#### Convert data into mousetrap obj
```{r}
# Convert mousetracking trajectories into mousetrap object
mt_obj <- mt_import_mousetrap(enc_mouse_paired, xpos_label='x_pos', ypos_label='y_pos', timestamps_label='time_trajectories', mt_id_label=NULL, split=' ', duplicates='remove_first', unordered='warn',reset_timestamps=T, digits=NULL, verbose=F)

# Obtain the mt measures
mt_analyzed <- mt_measures(mt_obj)

# Remove trajectories with no variance
mt_analyzed$data$pos_var <- apply(mt_analyzed$trajectories[,,"xpos"],1,var,na.rm=TRUE) + apply(mt_analyzed$trajectories[,,"ypos"],1,var,na.rm=TRUE)
mt_analyzed <- mt_subset(mt_analyzed, pos_var>0)

# Time normalize the trajectories
mt_analyzed = mt_time_normalize(mt_analyzed)

# Merge the measures with the actual data
mt_measures_data <- mt_analyzed$data %>% left_join(mt_analyzed$measures, by='mt_id')

# Print the amount of eligible mouse trajectories
cat('# of eligible mouse trajectories:', nrow(mt_analyzed$data))
```

#### Import the temporal memory accuracy data
```{r}
temp_num_all <- data.frame()

# Load in all of the temporal number data across all subs
for (s in sub_mem_files){
  # Import temporal memory for this sub
  temp_data <- read.csv(s)
  temp_data <- subset(temp_data, paired_status == 'paired')
  
  # Change the column name
  temp_data <- temp_data %>% dplyr::rename(sub_label = sub)
  temp_data_df <- temp_data %>% select(c('sub_label', 'temp_acc', 'image_stem'))
  temp_num_all <- rbind(temp_num_all, temp_data_df)}

# Extract second pairmates only (in line with main hypothesis)
mt_measures_p2_num <- subset(mt_measures_data, pairmate_num == 'second')

# Join mousetracking data with memory accuracy
mt_measures_p2_num$image_stem <- str_replace(mt_measures_p2_num$stimulus_path, '_1.jpg', '')
mt_measures_p2_num$image_stem <- str_replace(mt_measures_p2_num$image_stem, '_2.jpg', '')
mt_measures_p2_num <- mt_measures_p2_num %>% left_join(temp_num_all, by=c('sub_label', 'image_stem'))
```

```{r}
# Compare memory accuracy across conditions
temp_acc_avg <- mt_measures_p2_num %>% select(c(sub_label, condition, temp_acc, image_stem)) %>% 
                dplyr::group_by(sub_label, condition) %>% dplyr::summarise(avg_acc = mean(temp_acc), .groups = "drop")

temp_acc_ttest <- t.test(subset(temp_acc_avg, condition == 'unique')$avg_acc, subset(temp_acc_avg, condition == 'competing')$avg_acc, paired=T)
temp_acc_ttest # show results below
```

```{r, warning=FALSE}
# Suppressing warning about avenir font

# Plot difference in memory accuracy
cond_colors <- c('#FFD93D', '#762E84')
temp_acc_avg$avg_acc_percent <- temp_acc_avg$avg_acc * 100 # convert accuracy into percent accuracy

# Make sure conditions are in the correct order 
temp_acc_avg$condition <- factor(temp_acc_avg$condition, c('unique', 'competing'))

# Plot
temp_acc_plot <- ggplot(temp_acc_avg,aes(x=condition, y=avg_acc_percent, fill=condition)) +
              geom_bar(alpha=.9, stat='summary', fun.data=mean_se) +
              ylab('Mean Accuracy for Item Frequency Memory (%)') + xlab('Condition') +
              theme_classic() + theme(legend.position="none") +
              scale_fill_manual(values=cond_colors) +
              geom_beeswarm(size=3, alpha=0.6, color='black', method = "swarm", position=position_dodge(.7), priority='density', cex = 2) +
              theme(axis.title.x = element_text(size=12), axis.text.x  = element_text(vjust=0.5, size=10, color="black")) +
              theme(axis.title.y = element_text(size=12), axis.text.y  = element_text(vjust=0.5, size=15, color="black")) +
              scale_x_discrete(labels=c('Unique', 'Competing')) + 
              theme(text = element_text(family = "avenir")) + 
              ylim(0, 105) + 
              geom_hline(yintercept=50, linetype = 'dashed') # chance line

temp_acc_plot_final <- ggdraw(temp_acc_plot) + draw_text("***", x = 0.53, y = 0.92, size=30) + draw_text("____________", x = 0.53, y = 0.93, size=20)
temp_acc_plot_final
```

#### Run a mixed-effects logistic regression (relating MAD to memory accuracy)
```{r, warning=FALSE}
# Suppressing warning related to avenir font

# Mean-center the IVs
mt_measures_p2_num<-scale_within(mt_measures_p2_num, variables = c("MAD", "AUC", "AD"), within = c('sub_label'), prefix = "center.", center = T, scale = F) 

# Place conditions in order
mt_measures_p2_num$condition <- factor(mt_measures_p2_num$condition, c('unique', 'competing'))

# Run model (w/ random slopes for MAD)
mad_num_mod <- glmer(temp_acc ~ condition * center.MAD + (center.MAD|sub_label), data=mt_measures_p2_num, family='binomial')
summary(mad_num_mod)

# Visualize predicted values/marginal effects
mad_num_mod_plot <- plot_model(mad_num_mod, type='pred', terms=c('center.MAD[all]', 'condition'), colors=c('#FFD93D', '#762E84')) + theme_minimal() + xlab('Maximum Absolute Deviation \n(mean-centered)') + ylab('Number of Items Accuracy\n') + labs(title='', color='Goal Condition') + theme(text = element_text(family = "avenir"))

mad_num_mod_final_plot <- ggdraw(mad_num_mod_plot) + draw_text("*", x = 0.75, y = 0.83, size=35) + draw_text("ns", x = 0.75, y = 0.48, size=12)
mad_num_mod_final_plot
```

#### Additionally, visualize the random effects (to get a better understanding of indiv. differences)
```{r}
# Split subjects into accuracy groups
sub_acc_all <- mt_measures_p2_num %>% dplyr::group_by(sub_label, condition) %>% dplyr::summarise(mean_mem_acc = mean(temp_acc))
sub_acc_comp <- subset(sub_acc_all, condition == 'competing')

# Here, we split the subjects into terciles based on accuracy
sub_acc_comp <- sub_acc_comp %>% dplyr::mutate(acc_group = case_when(mean_mem_acc < quantile(sub_acc_all$mean_mem_acc, .33) ~ 'Low', mean_mem_acc < quantile(sub_acc_all$mean_mem_acc, .67) ~ 'Medium', .default = 'High'))
```

```{r, warning=FALSE}
# Suppressing warning related to avenir font

# Get random effects (intercept + MAD)
rand_effects <- ranef(mad_num_mod)$sub_label
rand_effects$sub_label <- rownames(rand_effects) # create column of sub labels 
colnames(rand_effects) <- c('random_intercept', 'random_slope_mad', 'sub_label')

# Get conf intervals (using se)
cond_var <- ranef(mad_num_mod, condVar = TRUE)
se_slope <- sqrt(attr(cond_var$sub_label, "postVar")[2, 2, ]); rand_effects$se_slope <- se_slope
rand_effects$lower <- rand_effects$random_slope_mad - 1.96 * se_slope
rand_effects$upper <- rand_effects$random_slope_mad + 1.96 * se_slope

# Set up the MAD range for values 
mad_range <- c(min(mt_measures_p2_num$center.MAD), max(mt_measures_p2_num$center.MAD))

# Gather predictions at levels of MAD
pred_data <- expand.grid(sub_label = unique(mt_measures_p2_num$sub_label), 
                         condition = unique(mt_measures_p2_num$condition), center.MAD = mad_range)
pred_data$predicted_prob <- predict(mad_num_mod, pred_data, type = "response")

# Get random slopes for each condition
sub_slopes <- pred_data %>% dplyr::group_by(sub_label, condition) %>% dplyr::summarise(slope = diff(predicted_prob)/diff(center.MAD), .groups = 'drop')

# Add in the accuracy groupings 
sub_slopes <- sub_slopes %>% left_join(sub_acc_comp, by=c('sub_label'))
sub_slopes <- sub_slopes %>% select(-c('condition.y', 'mean_mem_acc'))
colnames(sub_slopes) <- c('sub_label', 'condition', 'slope', 'acc_group')

# Sort subs by average slope 
sub_order <- sub_slopes %>% dplyr::group_by(sub_label) %>% dplyr::summarise(mean_slope = mean(slope)) %>% dplyr::arrange(mean_slope)
sub_slopes <- sub_slopes %>% mutate(sub_label = factor(sub_label, levels = sub_order$sub_label)) # order by factorizing

# Place accuracy in in order
sub_slopes$acc_group <- factor(sub_slopes$acc_group, c('Low', 'Medium', 'High'))

sub_slopes_plot <- ggplot(sub_slopes, aes(x = condition, y = slope, group = sub_label, color = acc_group)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black", linewidth = 1, alpha=.5) +
  geom_line(alpha = 0.4, linewidth = 0.8) +
  geom_point(size = 3, alpha = 0.8) +
  scale_color_manual(
    values = c("Low" = "#d62728", "Medium" = "#ff7f0e", "High" = "#2ca02c"),
    name = "Memory Accuracy\nGroup"
  ) +
  scale_x_discrete(expand = expansion(add = c(0.2, 0.2)), labels=c('Unique', 'Competing')) +
  labs(
    x = "Goal Condition",
    y = "Subject-specific MAD Effect (slope)",
    title = "Individual MAD Effects Across Goal Conditions",
    subtitle = "Each line = one subject", 
  ) +
  theme_minimal(base_size = 13) + theme(text = element_text(family = "avenir"))

sub_slopes_final_plot <- ggdraw(add_sub(sub_slopes_plot, "When memory demands are high (Competing condition), individuals with\nweaker memory benefit the most from decision conflict (MAD), suggesting that\ndeliberation between two options helps preserve memories.", size=12, fontfamily='avenir', fontface='italic'))
sub_slopes_final_plot

# Save visualization in png format
visualize_dir <- file.path(rootPath, 'visualizations')
if (!dir.exists(visualize_dir)) {dir.create(visualize_dir)} # create folder if it doesn't exist yet...
ggsave(file.path(visualize_dir, "03_mad_indiv_differences.png"), plot = sub_slopes_final_plot, width = 25, height = 20, units = "cm", dpi = 300, bg = "white")
```




